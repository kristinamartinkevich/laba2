1.Что такое .Net Frameworkи из чего он состоит?



.NET Framework — программная платформа, выпущенная компанией Microsoft в 2002 году. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), которая подходит для разных языков программирования. Функциональные возможности CLR доступны в любых языках программирования, использующих эту среду.

Считается, что платформа .NET Framework явилась ответом компании Microsoft на набравшую к тому времени большую популярность платформу Java компании Sun Microsystems (ныне принадлежит Oracle).

Хотя .NET является патентованной технологией корпорации Microsoft и официально рассчитана на работу под операционными системами семейства Microsoft Windows, существуют независимые проекты (прежде всего это Mono и Portable.NET), позволяющие запускать программы .NET на некоторых других операционных системах. В настоящее время .NET Framework получает развитие в виде .NET Core, изначально предполагающей кросcплатформенную разработку и эксплуатацию.



2.Поясните, что такое CLR-среда.

Common Language Runtime (англ. CLR — общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в который компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.

Среда CLR является реализацией спецификации CLI (англ. Common Language Infrastructure), спецификации общеязыковой инфраструктуры компании Microsoft.


3.Что такое FCL?

Framework Class Library (FCL)
Вторым типом библиотек платформы .NET Framework является библиотека классов платформы (FCL). Она является вторым основным компонентом платформы .NET, которая упрощают работу программиста, предоставляя ему, более расширенные библиотеки, такие как: ASP.NET, ADO.NET, Windows Forms, WPF.

В принципе можно сказать, что Framework Class Library включает в себя библиотеку базовых классов BCL, которая, по сути, является её ядром.

Тогда на вопрос, из каких основных компонентов состоит платформа .NET? Можно ответить так:

.NET Framework = CLR + FCL

Такую официальную формулировку так же приводят: MSDN, Wiki и многие другие авторы книг.

&#171;The key components of the .NET Framework are the common language runtime (CLR) and the .NET Framework class library&#187;. MSDN

Но мы знаем, что FCL включает в себя библиотеки базовых классов. И правильнее формулировка должна звучать так:

.NET Framework = CLR + Libraries (FCL, BCL) 
Но тут конечно можно долго спорить.



4.Какая наименьшая исполнимая единица в .NET?

Сборка (assembly) - один или несколько файлов, содержащий логический набор функциональности (код и другие данные, связанные с кодом). Бывают статические сборки, хранящиеся на диске, и динамические, которые создаются во время выполнения программы. Сборка - это базовый блок приложения, все ресурсы, относящиеся к ней, доступны или только внутри этого блока, или экспортируются наружу. При выполнении сборка задает область видимости имен и следит за ее соблюдением



5.Что такое IL?

IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.



6.Пояснить работу JIT-компилятора?

JIT-компиляция (англ. Just-in-time compilation, компиляция «на лету»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Таким образом достигается высокая скорость выполнения по сравнению с интерпретируемым байт-кодом[1] (сравнимая с компилируемыми языками) за счёт увеличения потребления памяти (для хранения результатов компиляции) и затрат времени на компиляцию. JIT базируется на двух более ранних идеях, касающихся среды исполнения: компиляции байт-кода и динамической компиляции.



7.Что такое CTS (Common Type System)?

Common Type System (сокр. CTS, рус. Общая система типов) — часть .NET Framework, формальная спецификация, определяющая, как какой-либо тип (класс, интерфейс, структура, встроенный тип данных) должен быть определён для его правильного выполнения средой .NET. Кроме того, данный стандарт определяет, как определения типов и специальные значения типов представлены в компьютерной памяти. Целью разработки CTS было обеспечение возможности программам, написанным на различных языках программирования, легко обмениваться информацией. Как это принято в языках программирования, тип может быть описан как определение набора допустимых значений (например, «все целые от 0 до 10») и допустимых операций над этими значениями (например, сложение и вычитание).



8.Какие аспекты поведения определяет  тип System.Object?

 
Поддерживает все классы в иерархии классов .NET Framework и предоставляет службы низкого уровня для производных классов. Он является исходным базовым классом для всех классов платформы .NET Framework и корнем иерархии типов.



9.Что находится в MSCorLib dll?


Mscorlib.ni.dll - это файл DLL в Windows. DLL - это аббревиатура от Dynamic Link Library (динамически подключаемая библиотека). DLL файлы необходимы программам или расширениям веб-браузера, потому что они содержат программный код, данные и ресурсы. Бесплатный форум с информацией о файлах может помочь вам разобраться является ли mscorlib.ni.dll вирусом, трояном, программой-шпионом, рекламой, которую вы можете удалить, или файл принадлежит системе Windows или приложению, которому можно доверять.




10.Что такое частные и общие сборки?

Частные находятся в каталоге программы, а общие в GAC


11.Что такое assembly manifest?

Манифест сборки (assembly manifest) - это внутренняя часть сборки, которая позволяет ей быть самоописанной. Assembly manifest позволяет идентифицировать сборку, указывает файлы, которые включаются в реализацию сборки, описывает типы и ресурсы, используемые в сборке, указывает зависимости от других сборок, а также набор прав доступа, которые необходимы сборке для корректной работы. Эта информация используется во время выполнения для разрешения ссылок, проверку корректности версий, проверку целостности загруженных сборок.



12.Что такое GAC?


GAC — это глобальный кэш сборок. В нем хранятся совместно используемые сборки. Обычно это каталог С:\Windows\Assembly\GAC. Этот каталог имеет определенную структуру, в котором хранятся подкаталоги, имена которых сгенерированы по определенному алгоритму. В GAC можно поместить только сборки со строгими именами. Для того, чтобы поместить сборку в GAC, используют специальный инструмент GACUtil.exe, который знает всю внутреннюю структуру GAC и может генерировать имена подкаталогов надлежащим образом. Регистрировать в GAC сборки необходимо для того, чтобы избежать конфликтов имен сборок. Приведем пример: две компании выпустили сборку и назвали ее одним именем Calculus. Если мы скопируем эту сборку в каталог, в котором уже находится сборка с таким же именем, то мы затрем сборку, которая ранее могла использоваться каким-то приложением. Это приложение с новой сборкой теперь работать не сможет. Решением этой проблемы будет регистрация этих двух сборок в GAC, в котором для каждой будет создан отдельный каталог.



13.Чем managed code отличается отunmanaged code

Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде


14.Как и для чего определен метод Main?


В каждом приложении на C# должен присутствовать один метод Main, указывающий точку начала выполнения программы. В языке C# Main пишется с прописной буквы, в то время как в языке Java используется нижний регистр main.
Main может возвращать только int или void, и имеет необязательный аргумент массива строк для представления параметров командной строки:


15.Варианты использования директивы using( using Directive ) в C#.

Директива using используется в следующих трех целях.
Для разрешения использования типов в пространстве имен, чтобы не нужно было квалифицировать использование типа в этом пространстве имен:
C#

Копировать
using System.Text;  
Для разрешения доступа к статическим членам типа без необходимости квалификации доступа с помощью имени типа:
C#

Копировать
using static System.Math;  
Дополнительные сведения см. в разделе Директива using static.
Чтобы создать псевдоним для пространства имен или типа. Это называется директивой using static.
C#

Копировать
using Project = PC.MyCompany.Project;  
Ключевое слово using также используется для создания операторов using, которые помогают обеспечить правильную обработку объектов IDisposable, таких как файлы и шрифты. Дополнительные сведения см. в разделе Оператор using.



16.Как связаны между собой сборкии пространства имен?

перед использованием using SomeNameSpace;, вы должны указать в проекте ссылку на сборку, в которой объявлены типы данного пространства имен. Но это не ни как не влияет на то, что сборки и пространства имен не имеют жесткой связи на уровне языка и платформы. Пространства имен - всего лишь агрегатная приставка к имени типа для явного указания принадлежности типа к определенной группе логически связанных типов, не более того. А вот типы, в отличие от пространств имен, имеют жесткую связь со сборкой в которой находятся,



17.Что такое примитивные типы данных?Перечислите их.

binary
Содержит двоичные данные.
MaxLength, FixedLength, Nullable, Default
Boolean
Содержит значение true или false.
Nullable, Default
Byte
Содержит 8-битное целое значение без знака.
Precision, Nullable, Default
DateTime
Представляет дату и время.
Precision, Nullable, Default
DateTimeOffset
Возвращает дату и время в виде смещения в минутах от времени GMT.
Precision, Nullable, Default
decimal
Содержит точное числовое значение с заданной точностью и масштабом.
Precision, Nullable, Default
Double
Содержит число с плавающей запятой с точностью до 15 цифр.
Precision, Nullable, Default
float
Содержит число с плавающей запятой с точностью до 7 цифр.
Precision, Nullable, Default
Guid
Содержит уникальный 16-битный идентификатор.
Precision, Nullable, Default
Int16
Содержит 16-разрядное целое значение со знаком.
Precision, Nullable, Default
Int32
Содержит 32-разрядное целое значение со знаком.
Precision, Nullable, Default
Int64
Содержит 64-разрядное целое значение со знаком.
Precision, Nullable, Default
SByte
Содержит 8-разрядное целое значение со знаком.
Precision, Nullable, Default
string
Содержит символьные данные.
Unicode, FixedLength, MaxLength, Collation, Precision, Nullable, Default
Время
Содержит время дня.
Precision, Nullable, Default



18,19,20.Что такое ссылочные типы? Какие типы относятся к ним?
Какие типы относятся к типам-значениям?В чем отличие между ссылочными и значимыми типами данных?

В отличие от некоторых языков программирования, C # имеет две разновидности типов данных: для значения и для ссылки. Если производительность приложения имеет существенное значение или есть заинтересованность в том, как C# управляет данными и памятью, важно знать различия между этими типами.
Если в объявлении переменной используется один из основных встроенных типов данных или определенная пользователем структура данных, значит мы имеем дело с типом значения. Исключение составляет тип данных string, который является ссылочным типом.
Тип значения хранит свое содержимое в памяти, выделенной в стеке. Например, значение 42 в таком случае хранится в области памяти, называемой стеком.

int x = 42;


При выходе переменной x из области действия в связи с завершением выполнения метода, в котором она была объявлена, значение удаляется из стека.
Использование стека является эффективным, но ограниченное время существования типов значений делает их менее подходящими для совместного использования данных между различными классами.
В отличие от этого ссылочный тип, такой как экземпляр класса или массив, размещается в другой области памяти, называемой кучей. В следующем примере пространство, необходимое для массива из десяти целых чисел, размещается в куче.

int[] numbers = new int[10];


Эта память не возвращается к куче при завершении метода, она освобождается только когда система сборки мусора C# определит, что она больше не нужна. Объявление ссылочных типов увеличивает расход ресурсов, но их преимущество заключается в том, что они могут быть доступны из других классов.


Тип object

Тип string

Классы (class)

Интерфейсы (interface)

Делегаты (delegate)


21.Что такое упаковка и распаковка значимых типов?

Упаковкой называется процесс преобразования типа значения в ссылочный тип. Для упаковки переменной необходимо создать ссылочную переменную, указывающую на новую копию в куче. Ссылочная переменная является объектом, следовательно для нее можно использовать все методы, наследуемые каждым объектом, например ToString(). В следующем коде показано, как это происходит.
C#
int i = 67;                              // i is a value type
object o = i;                            // i is boxed
System.Console.WriteLine(i.ToString());  // i is boxed


Распаковка применяется для классов, предназначенных для работы с объектами: например, использование ArrayList для хранения целых чисел. Для хранения целых чисел в ArrayList используется упаковка. При извлечении целого числа должна быть применена распаковка.
C#
System.Collections.ArrayList list = 
    new System.Collections.ArrayList();  // list is a reference type
int n = 67;                              // n is a value type
list.Add(n);                             // n is boxed
n = (int)list[0];                        // list[0] is unboxed





22.Для чего используется тип dynamic?

C# 4 добавляет новый тип dynamic. Этот тип является статическим, но объект типа dynamic обходит проверку статического типа. В большинстве случаев он работает как тип object. Во время компиляции предполагается, что элемент, типизированный как dynamic, поддерживает любые операции. Это значит, что вам не придется задумываться о том, получает ли объект значение из API COM, из динамического языка, такого как IronPython, из модели DOM HTML, из отражения или из другой части программы. При этом если код недопустимый, ошибки перехватываются во время выполнения.


23.Что такое неявно типизированная переменная?

Локальные переменные можно объявлять без указания конкретного типа. Ключевое слово var указывает, что компилятор должен вывести тип переменной из выражения справа от оператора инициализации. Выведенный тип может быть встроенным, анонимным, определяемым пользователем либо типом, определяемым в библиотеке классов .NET Framework. 


24.Для чего используют Nullableтип?

Типы, допускающие значения NULL, являются экземплярами структуры System.Nullable<T>. Тип, допускающий значение NULL, может принимать такой же диапазон значений, как и его базовый тип значения, а также дополнительное значение null. Например, для типа Nullable<Int32> (Int32, допускающий значения NULL) можно назначить любое значение в диапазоне от -2147483648 до 2147483647 или значение null. Тип Nullable<bool> может иметь значения true, false, или null. Возможность назначения null для числовых и логических типов особенно полезна при работе с базами данных и другими источниками данных, которые могут содержать элементы без присвоенного значения. Например, логическое поле в базе данных может хранить значения true или false, или может быть неопределенным.


25.Как объявить строковый литерал? Какие операции можно выполнять со строкой?


Строка — это объект типа String, значением которого является текст. Внутри программы текст хранится в виде упорядоченной коллекции объектов Char только для чтения. В конце строки C# нет нуль-символов. Поэтому строка C# может содержать любое число внедренных нуль-символов ('\0'). Свойство Length строки соответствует числу содержащихся в ней объектов Char, но не числу символов Юникода. Для доступа к отдельным кодовым точкам Юникода в строке используйте объект StringInfo.

В C# поддерживается еще один тип литералов — строковый. Строковый литерал представляет собой набор символов, заключенных в двойные кавычки. Например следующий фрагмент кода:

"This is text"
Помимо обычных символов, строковый литерал может содержать одну или несколько управляющих последовательностей символов, о которых речь шла выше. Также можно указать буквальный строковый литерал. Такой литерал начинается с символа @, после которого следует строка в кавычках. Содержимое строки в кавычках воспринимается без изменений и может быть расширено до двух и более строк. Это означает, что в буквальный строковый литерал можно включить символы новой строки, табуляции и прочие, не прибегая к управляющим последовательностям. Единственное исключение составляют двойные кавычки ("), для указания которых необходимо использовать двойные кавычки с обратным слэшем ("\").


операции:
Конкатенация
Сравнение строк
Поиск в строке
Разделение строк
Обрезка строки
Вставка
Удаление строк
Замена
Смена регистра

26.Какие есть способы для задания и инициализации строк?


Вы можете объявлять и инициализировать строки различными способами, как показано в следующем примере:

// Declare without initializing.
string message1;

// Initialize to null.
string message2 = null;

// Initialize as an empty string.
// Use the Empty constant instead of the literal "".
string message3 = System.String.Empty;

//Initialize with a regular string literal.
string oldPath = "c:\\Program Files\\Microsoft Visual Studio 8.0";

// Initialize with a verbatim string literal.
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

// Use System.String if you prefer.
System.String greeting = "Hello World!";

// In local variables (i.e. within a method body)
// you can use implicit typing.
var temp = "I'm still a strongly-typed System.String!";

// Use a const string to prevent 'message4' from
// being used to store another string value.
const string message4 = "You can't get rid of me!";

// Use the String constructor only when creating
// a string from a char*, char[], or sbyte*. See
// System.String documentation for details.
char[] letters = { 'A', 'B', 'C' };
string alphabet = new string(letters);



 
27.Какие методы есть у типа String?








Compare()-Статический метод, сравнивает строку strA со строкой strB. Возвращает положительное значение, если строка strA больше строки strB; отрицательное значение, если строка strA меньше строки strB; и нуль, если строки strA и strB равны. Сравнение выполняется с учетом регистра и культурной среды.

Если параметр ignoreCase принимает логическое значение true, то при сравнении не учитываются различия между прописным и строчным вариантами букв. В противном случае эти различия учитываются.

Параметр comparisonType определяет конкретный способ сравнения строк. Класс CultureInfo определен в пространстве имен System.Globalization.



CompareOrdinal()-Делает то же, что и метод Compare(), но без учета локальных установок


CompareTo()-Сравнивает вызывающую строку со строковым представлением объекта value. Возвращает положительное значение, если вызывающая строка больше строки value; отрицательное значение, если вызывающая строка меньше строки value; и нуль, если сравниваемые строки равны


Equals()-Возвращает логическое значение true, если вызывающая строка содержит ту же последовательность символов, что и строковое представление объекта obj. Выполняется порядковое сравнение с учетом регистра, но без учета культурной среды

Concat()-Комбинирует отдельные экземпляры строк в одну строку (конкатенация


Contains()-Метод, который позволяет определить, содержится ли в строке определенная подстрока (value)



StartsWith()-Возвращает логическое значение true, если вызывающая строка начинается с подстроки value. В противном случае возвращается логическое значение false. Параметр comparisonType определяет конкретный способ выполнения поиска



EndsWith()-Возвращает логическое значение true, если вызывающая строка оканчивается подстрокой value. В противном случае возвращает логическое значение false. Параметр comparisonType определяет конкретный способ поиска

IndexOf()-Находит первое вхождение заданной подстроки или символа в строке. Если искомый символ или подстрока не обнаружены, то возвращается значение -1


LastIndexOf()-То же, что IndexOf, но находит последнее вхождение символа или подстроки, а не первое


IndexOfAny()-Возвращает индекс первого вхождения любого символа из массива anyOf, обнаруженного в вызывающей строке. Поиск начинается с элемента, указываемого по индексу startIndex, и охватывает число элементов, определяемых параметром count (если они указаны). Метод возвращает значение -1, если не обнаружено совпадение ни с одним из символов из массива anyOf. Поиск осуществляется порядковым способом


LastIndexOfAny-Возвращает индекс последнего вхождения любого символа из массива anyOf, обнаруженного в вызывающей строке



Split-Метод, возвращающий массив string с присутствующими в данном экземпляре подстроками внутри, которые отделяются друг от друга элементами из указанного массива char или string.

В первой форме метода Split() вызывающая строка разделяется на составные части. В итоге возвращается массив, содержащий подстроки, полученные из вызывающей строки. Символы, ограничивающие эти подстроки, передаются в массиве separator. Если массив separator пуст или ссылается на пустую строку, то в качестве разделителя подстрок используется пробел. А во второй форме данного метода возвращается количество подстрок, определяемых параметром count.



Join()-Строит новую строку, комбинируя содержимое массива строк.

В первой форме метода Join() возвращается строка, состоящая из сцепляемых подстрок, передаваемых в массиве value. Во второй форме также возвращается строка, состоящая из подстрок, передаваемых в массиве value, но они сцепляются в определенном количестве count, начиная с элемента массива value[startIndex]. В обеих формах каждая последующая строка отделяется от предыдущей разделительной строкой, определяемой параметром separator.


Trim()-Метод, который позволяет удалять все вхождения определенного набора символов с начала и конца текущей строки.

В первой форме метода Trim() из вызывающей строки удаляются начальные и конечные пробелы. А во второй форме этого метода удаляются начальные и конечные вхождения в вызывающей строке символов из массива trimChars. В обеих формах возвращается получающаяся в итоге строка.


PadLeft()-Позволяет дополнить строку символами слева.

В первой форме метода PadLeft() вводятся пробелы с левой стороны вызывающей строки, чтобы ее общая длина стала равной значению параметра totalWidth. А во второй форме данного метода символы, обозначаемые параметром paddingChar, вводятся с левой стороны вызывающей строки, чтобы ее общая длина стала равной значению параметра totalWidth. В обеих формах возвращается получающаяся в итоге строка. Если значение параметра totalWidth меньше длины вызывающей строки, то возвращается копия неизмененной вызывающей строки.



PadRight()-Позволяет дополнить строку символами справа.



Insert()-Используется для вставки одной строки в другую, где value обозначает строку, вставляемую в вызывающую строку по индексу startIndex. Метод возвращает получившуюся в итоге строку.


Remove()-Используется для удаления части строки. В первой форме метода Remove() удаление выполняется, начиная с места, указываемого по индексу startIndex, и продолжается до конца строки. А во второй форме данного метода из строки удаляется количество символов, определяемое параметром count, начиная с места, указываемого по индексу startIndex.


Replace()-Используется для замены части строки. В первой форме метода Replace() все вхождения символа oldChar в вызывающей строке заменяются символом newChar. А во второй форме данного метода все вхождения строки oldValue в вызывающей строке заменяются строкой newValue.


ToUpper()-Делает заглавными все буквы в вызывающей строке

ToLower()-Делает строчными все буквы в вызывающей строке.


Substring()-В первой форме метода Substring() подстрока извлекается, начиная с места, обозначаемого параметром startIndex, и до конца вызывающей строки. А во второй форме данного метода извлекается подстрока, состоящая из количества символов, определяемых параметром length, начиная с места, обозначаемого параметром startIndex.









28.В чем отличие пустой и nullстроки?
Строка — null если ей не было назначено значение (в C++ и Visual Basic) или явно назначено значение null.
Строка пуста, если явно присваивается пустая строка ("») или String.Empty. Пустая строка имеет Length 0.


29.Как можно выполнить сравнение строк?

Статический метод String.Compare позволяет тщательно сравнивать две строки. Этот метод учитывает язык и региональные параметры. Эту функцию можно использовать для сравнения двух строк или подстрок двух строк. Кроме того, имеются перегруженные методы, которые учитывают или не учитывают регистр и вариативность языка и региональных параметров. В таблице ниже приведены три целочисленных значения, которые может возвращать этот метод.
Возвращаемое значение
Condition
Отрицательное целое число
Первая строка предшествует второй в порядке сортировки.
-или-
Первая строка имеет значение null.
0
Первая и вторая строка равны.
-или-
Обе строки имеют значение null.
Положительное целое число
-или-
1
Первая строка следует за второй в порядке сортировки.
-или-
Вторая строка имеет значение null.


30.В чем отличие типов Stringи StringBuilder?

Хотя класс System.String предоставляет нам широкую функциональность по работе со строками, все таки он имеет свои недостатки. Прежде всего, объект String представляет собой неизменяемую строку. Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места. Удаление первого символа - не самая затратная операция. Однако когда подобных операций множество, а объем текста, для которого надо выполнить данные операции, также не самый маленький, то издержки при потере производительности становятся более существенными.

Чтобы выйти из этой ситуации во фреймворк .NET был добавлен новый класс StringBuilder, который находится в пространстве имен System.Text. Этот класс представляет динамическую строку.

При создании объекта StringBuilder выделяется память по умолчанию для 16 символов, так как длина начальной строки меньше 16.

Дальше применяется метод Append - этот метод добавляет к строке подстроку. Так как при объединении строк их общая длина - 22 символа - превышает начальную емкость в 16 символов, то начальная емкость удваивается - до 32 символов.

Если бы итоговая длина строки была бы больше 32 символов, то емкость расширялась бы до размера длины строки.

Далее опять применяется метод Append, однако финальная длина уже будет 28 символов, что меньше 32 символов, и дополнительная память не будет выделяться.

Кроме метода Append класс StringBuilder предлагает еще ряд методов для операций над строками:

Insert: вставляет подстроку в объект StringBuilder, начиная с определенного индекса

Remove: удаляет определенное количество символов, начиная с определенного индекса

Replace: заменяет все вхождения определенного символа или подстроки на другой символ или подстроку

AppendFormat: доабвляет подстроку в конец объекта StringBuilder

Когда надо использовать класс String, а когда StringBulder?

Microsoft рекомендует использовать класс String в следующих случаях:

При небольшом количестве операций и изменений над строками

При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну

Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StringBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:

При неизвестном количестве операций и изменений над строками во время выполнения программы

Когда предполагается, что приложению придется сделать множество подобных операций





31.Поясните явные преобразования переменных с помощью команд Convert.


В пространстве имен System имеется класс Convert, которы может применяться для расширения и сужения данных

Преобразует значение одного базового типа данных к другому базовому типу данных.

byte sum = Convert.ToByte(var1 + var2);
Одно из преимуществ подхода с применением класса System.Convert связано с тем, что он позволяет выполнять преобразования между типами данных нейтральным к языку образом (например, синтаксис приведения типов в Visual Basic полностью отличается от предлагаемого для этой цели в C#). Однако, поскольку в C# есть операция явного преобразования, использование класса Convert для преобразования типов данных обычно является делом вкуса.


32.Как выполнить консольный ввод/вывод?


Консольный ввод / вывод применяется, соответственно, во всех консольных приложениях. Многим щас кажется, что консольное приложение это пережиток прошлого. Но на самом деле это не так. Вот доказательства:

практически все сервера разработаны именно в консольном виде
ОС Linux и ее различные вариации так же для создания важных системных приложений использует консольную среду
Консольное приложение выигрывает в первую очередь в ресурсах системы, что в нашу эру архи важный показатель качества. Давайте же рассмотри консольный ввод / вывод подробнее. А именно статические методы класса Console:

   Метод ReadLine

Метод ReadLine считывает ввод пользователя. Возвращается строка типа string. Так же метод ReadLine используется для задержки программы.

   Метод ReadKey

Метод ReadKey считывает из потока введенный символ или функциональную клавишу. Символ отображается на консоли. Так же метод ReadKey может использоваться для задержки выполнения программы.

   Метод Read

Метод Read действует аналогично с методом ReadKey.

   Метод WriteLine

Метод WriteLine записывает на консоль заданную строку. Метод WriteLine имеет множество перегрузок. Но давайте рассмотрим наиболее сложную констуркцию, которая применяется чаще всего:

Console.WriteLine(string format, object args[]);

Параметр format является форматом вывода строки. Вторым параметром следует список всех переменных, которые будут выводиться:

int a = 16;
string str = "proba";
Console.WriteLine("число = {0}, строка = {1}", a, str);

Действие очень похоже на оператор printf() в языке С. В квадратных скобках указывается по порядку вставка переменных, которые, далее, перечисляются через запятую. Причем, в какой очередности вы запишите операторы, в той они и будут выводиться на консоль.

Но просто выводить значения нам не всегда хочется. Допустим, для ввода даты нам уже необходим слегка другой формат вывода. И эта проблема так же имеет свое решение. Поэтому в фигурные скобки может быть включена и другая информация:

количество символов
показывает сколько цифр будет занимать представление элемента. Указывается после значения индекса и разделяется запятой:

Console.WriteLine("{0,10}",d);

Если значение положительное, то выравнивается по правому краю. Иначе - по левому.

спецификатор формата
указывается, в какой именно форме будут выводиться наши значения.

Console.WriteLine("{0,10:C}",d);

Список основных спецификаторов для консольного ввода / вывода лучше покажу на рисунке:

виды спецификаторов Console.Writeline()
   Метод Write

Метод Write действует так же как и метод WriteLine, только не посылает на вывод знак перехода на следующую строку.


33.Приведите примеры определения и инициализации одномерных и двумерных массивов.



употреблять термин «матрица» как синоним термина «двумерный массив». В C/C++ прямоугольный двумерный массив чисел действительно реализует математическое понятие «матрица». Однако, в общем случае, двумерный массив — понятие гораздо более широкое, чем матрица, поскольку он может быть и не прямоугольным, и не числовым.

Определение автоматических многомерных массивов почти полностью совпадает с определением одномерных массивов, за исключением того, что вместо одного размера может быть указано несколько:

const unsigned int DIM1 = 3;
const unsigned int DIM2 = 5;

int ary[DIM1][DIM2];
В этом примере определяется двумерный массив из 3 строк по 5 значений типа int в каждой строке. Итого 15 значений типа int.

const unsigned int DIM1 = 3;
const unsigned int DIM2 = 5;
const unsigned int DIM3 = 2;

int ary[DIM1][DIM2][DIM3];
Во втором примере определяется трёхмерный массив, содержащий 3 матрицы, каждая из которых состоит из 5 строк по 2 значения типа int в каждой строке.

Понятно, что тип данных, содержащихся в многомерном массиве, может быть любым.

При дальнейшем изложении для таких многомерных массивов будет употребляться термин «C-массив», что бы отличать их от массивов других видов.

При статической (определяемой на этапе компиляции) инициализации значения C-массива перечисляются в порядке указания размеров (индексов) в определении массива. Каждый уровень (индекс), кроме самого младшего, многомерного массива заключается в свою пару фигурных скобок. Значения самого младшего индекса указываются через запятую:

const unsigned int DIM1 = 3;
const unsigned int DIM2 = 5;

int ary[DIM1][DIM2] = {
    { 1, 2, 3, 4, 5 },
    { 2, 4, 6, 8, 10 },
    { 3, 6, 9, 12, 15 }
};
В примере показана статическая инициализация прямоугольного массива. Весь список инициализирующих значений заключён в фигурные скобки. Значения для каждой из 3 строк заключены в свою пару из фигурных скобок, значения для каждого из 5 столбцов для каждой строки перечислены через запятую.

При наличии инициализатора, самый левый размер массива может быть опущен. В этом случае компилятор сам определит этот размер, исходя из списка инициализации.



34.Что такое ступенчатый массив? Как его задать?
Двумерный массив можно представить в виде таблицы, в которой длина каждой строки остается неизменной по всему массиву. Но в C# можно также создавать специальный тип двумерного массива, называемый ступенчатым массивом. Ступенчатый массив представляет собой массив массивов, в котором длина каждого массива может быть разной. Следовательно, ступенчатый массив может быть использован для составления таблицы из строк разной длины.

Ступенчатые массивы объявляются с помощью ряда квадратных скобок, в которых указывается их размерность. Например, для объявления двумерного ступенчатого массива служит следующая общая форма:

тип [][] имя массива = new тип[размер] [];
где размер обозначает число строк в массиве. Память для самих строк распределяется индивидуально, и поэтому длина строк может быть разной.



35.Какие типы можно использовать в foreach? Приведите пример.



Оператор foreach повторяет группу встроенных операторов для каждого элемента в массиве или коллекции объектов, которые реализуют интерфейс System.Collections.IEnumerable или System.Collections.Generic.IEnumerable<T>. Оператор foreach используется для итерации по коллекции для получения необходимых сведений, однако его нельзя использовать для добавления или удаления элементов из исходной коллекции во избежание непредвиденных побочных эффектов. Если требуется добавить или удалить элементы из исходной коллекции, используйте цикл for.
Внедренные операторы продолжают выполняться для каждого элемента массива или коллекции. После завершения итерации для всех элементов коллекции управление передается следующему оператору после блока foreach.
В любой момент в блоке foreach вы можете прервать цикл с помощью ключевого слова break или перейти к следующей итерации с помощью ключевого слова continue.
Из цикла foreach также можно выйти с помощью операторов goto, return или throw.
Дополнительные сведения о ключевом слове foreach и примеры кода см. в следующих разделах:
Использование оператора foreach с массивами
Практическое руководство. Доступ к классу коллекции с помощью оператора foreach
Пример
В коде ниже приведено три примера:
типичный цикл foreach, который отображает содержимое массива целых чисел;
цикл for, который делает то же самое;
цикл foreach, который ведет подсчет числа элементов в массиве.
C#

Копировать
class ForEachTest
{
    static void Main(string[] args)
    {
        int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };
        foreach (int element in fibarray)
        {
            System.Console.WriteLine(element);
        }
        System.Console.WriteLine();


        // Compare the previous loop to a similar for loop.
        for (int i = 0; i < fibarray.Length; i++)
        {
            System.Console.WriteLine(fibarray[i]);
        }
        System.Console.WriteLine();


        // You can maintain a count of the elements in the collection.
        int count = 0;
        foreach (int element in fibarray)
        {
            count += 1;
            System.Console.WriteLine("Element #{0}: {1}", count, element);
        }
        System.Console.WriteLine("Number of elements in the array: {0}", count);
    }
    // вывод:
    // 0
    // 1
    // 1
    // 2
    // 3
    // 5
    // 8
    // 13

    // 0
    // 1
    // 1
    // 2
    // 3
    // 5
    // 8
    // 13

    // Element #1: 0
    // Element #2: 1
    // Element #3: 1
    // Element #4: 2
    // Element #5: 3
    // Element #6: 5
    // Element #7: 8
    // Element #8: 13
    // кол-во элементов в массиве: 8
}



36.Что такое кортеж? Для чего и как он используется?

Массивы комбинируют объекты одного типа, а кортежи (tuple) могут комбинировать объекты различных типов. Понятие кортежей происходит из языков функционального программирования, таких как F#, где они часто используются. С появлением .NET 4 кортежи стали доступны в .NET Framework для всех языков .NET.

В .NET 4 определены восемь обобщенных классов Tuple и один статический класс Tuple, который служит фабрикой кортежей. Существуют различные обобщенные классы Tuple для поддержки различного количества элементов; например, Tuple<T1> содержит один элемент, Tuple<T1, Т2> — два элемента и т.д. Элементы кортежа могут быть доступны через свойства Item1, Item2 ... .

В случае если имеется более восьми элементов, которые нужно включить в кортеж, можно использовать определение класса Tuple с восемью параметрами. Последний параметр называется TRest, в котором должен передаваться сам кортеж. Таким образом, есть возможность создавать кортежи с любым количеством параметров.



37.Что такое локальная функция?

Visual Studio 2017).

Определим и используем локальную функцию:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
class Program
{
    static void Main(string[] args)
    {
        var result = GetResult(new int[] { -3, -2, -1, 0, 1, 2, 3 });
        Console.WriteLine(result);  // 6
        Console.Read();
    }
 
    static int GetResult(int[] numbers)
    {
        int limit = 0;
        // локальная функция
        bool IsMoreThan(int number)
        {
            return number > limit;
        }
 
        int result = 0;
        for(int i=0; i < numbers.Length; i++)
        {
            if (IsMoreThan(numbers[i]))
            {
                result += numbers[i];
            }
        }
 
        return result;
    }
}
Здесь в методе GetResult определена локальная функция IsMoreThan(), которая может быть вызвана только внутри этого метода. Локальная функция задает еще одну область видимости, где мы можем определять переменные и выполнять над ними действия. В то же время ей доступны все переменные, которые определены в том же методе.

При использовании локальных функций следует помнить, что они не могут иметь модификаторов доступа (public, private, protected). Нельзя определить в одном методе несколько локальных функций с одним и тем же именем, даже если у них будет разный список параметров. Кроме того, не имеет значения, определены локальные функции до своего вызова или после.



